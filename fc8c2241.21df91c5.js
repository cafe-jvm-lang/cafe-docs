(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{86:function(n,e,c){"use strict";c.r(e),c.d(e,"frontMatter",(function(){return o})),c.d(e,"metadata",(function(){return r})),c.d(e,"toc",(function(){return l})),c.d(e,"default",(function(){return s}));var a=c(3),t=c(7),i=(c(0),c(95)),o={id:"functional-programming",title:"() {Functional Programming}",sidebar_label:"Functional Programming",slug:"/advanced/functional"},r={unversionedId:"advanced/functional-programming",id:"advanced/functional-programming",isDocsHomePage:!1,title:"() {Functional Programming}",description:"Closure",source:"@site/docs/advanced/functional-programming.md",slug:"/advanced/functional",permalink:"/cafe-docs/docs/advanced/functional",editUrl:"https://github.com/cafe-jvm-lang/cafe-docs/tree/master/docs/advanced/functional-programming.md",version:"current",sidebar_label:"Functional Programming",sidebar:"docs",previous:{title:"Prototypes",permalink:"/cafe-docs/docs/advanced/"},next:{title:"Modular Programming",permalink:"/cafe-docs/docs/advanced/modular"}},l=[{value:"Closure",id:"closure",children:[{value:"Lexical Scoping",id:"lexical-scoping",children:[]},{value:"More Closer to <code>Closure</code>",id:"more-closer-to-closure",children:[]},{value:"Practical use of Closure",id:"practical-use-of-closure",children:[]}]},{value:"Higher-Order Functions",id:"higher-order-functions",children:[{value:"<code>function are first-class objects!</code>",id:"function-are-first-class-objects",children:[]}]},{value:"Anonymous Function",id:"anonymous-function",children:[]}],u={toc:l};function s(n){var e=n.components,c=Object(t.a)(n,["components"]);return Object(i.b)("wrapper",Object(a.a)({},u,c,{components:e,mdxType:"MDXLayout"}),Object(i.b)("h2",{id:"closure"},"Closure"),Object(i.b)("h3",{id:"lexical-scoping"},"Lexical Scoping"),Object(i.b)("p",null,"To understand closure let's first take a look at Lexical scoping using example below:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"func testScope() {  \n    var test = \u201cIn Lexical Scope\u201d;  \n    func insideScope() {        \n        cmd.println(test);\n    }\n}\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"testScope")," creates local variable ",Object(i.b)("inlineCode",{parentName:"p"},"test")," and instance of function ",Object(i.b)("inlineCode",{parentName:"p"},"insideScope")," ."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"insideScope()")," displays value of ",Object(i.b)("inlineCode",{parentName:"p"},"test")," variable,which is declared in its parent function. "),Object(i.b)("p",null,"Variable ",Object(i.b)("inlineCode",{parentName:"p"},"test"),"  is not available in ",Object(i.b)("inlineCode",{parentName:"p"},"insideScope")," which is referred as ",Object(i.b)("strong",{parentName:"p"},"Lexical Scope"),"."),Object(i.b)("h3",{id:"more-closer-to-closure"},"More Closer to ",Object(i.b)("inlineCode",{parentName:"h3"},"Closure")),Object(i.b)("p",null,"Closure  is a function enclosed within another function having some variable(state).\nExample:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"func outerFunction() {  \n    var a = 10; \n    func innerFunction() {      \n        cmd.println(\u201cA Inside: \u201c+a); // a \n    }\n    return innerFunction;\n}\nvar useClosure = outerFunction();\nuseClosure(); # A Inside: 10\n")),Object(i.b)("p",null,"Call to ",Object(i.b)("inlineCode",{parentName:"p"},"outerFunction")," is returning ",Object(i.b)("inlineCode",{parentName:"p"},"innerFunction "),"(\u2018closure\u2019 ) which captures the variable ",Object(i.b)("inlineCode",{parentName:"p"},"a"),".Variable ",Object(i.b)("inlineCode",{parentName:"p"},"a")," can be accessed only by ",Object(i.b)("inlineCode",{parentName:"p"},"innerFunction ")," outside its Lexical Scope so it can be referred as variable private to ",Object(i.b)("inlineCode",{parentName:"p"},"innerFunction"),"."),Object(i.b)("h3",{id:"practical-use-of-closure"},"Practical use of Closure"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"func Account() {    \n    var amount = 0; \n    func updateAmount(withAmnt) {       \n        balance = balance + withAmnt;   \n    }\n    return {        \n        deposit: func(b) {          \n            updateAmount(b);        \n        },\n        withdraw: func(b) { \n            if(b > amount) {        \n                cmd.println(\u201cInsufficient balance\u201d);    \n            } else {    \n                updateAmount(-b);\n            }\n        },\n        checkBalance: func() {  \n            cmd.println(amount);\n        }   \n    };\n}\nvar acc = Account();\nacc.checkBalance();\nacc.deposit(1000);\nacc.withdraw(2000);\n")),Object(i.b)("h2",{id:"higher-order-functions"},"Higher-Order Functions"),Object(i.b)("h3",{id:"function-are-first-class-objects"},Object(i.b)("inlineCode",{parentName:"h3"},"function are first-class objects!")),Object(i.b)("p",null,"In cafe, functions are first-class objects.\nThus, a function can be assigned to a variable, can be passed as an argument & can be returned inside a function."),Object(i.b)("p",null,"When a function is declared, internally a Function object is created and is assigned to variable."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"func Hello(){\n}\n# Is internally interpreted as\n# var Hello = `Function` Object                                    \n")),Object(i.b)("p",null,"Thus, it becomes possible to use functions as any other variables."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"func A(fn){\n    fn();\n}\nfunc B(){\n    cmd.print(\u201cI\u2019m B\u201d);\n}\nfunc Z(){\n    return B;\n}\nvar obj = {\n    Foo: A,\n};\n\nvar b = obj.Foo(Z);\nb(); # I\u2019m B\n")),Object(i.b)("h2",{id:"anonymous-function"},"Anonymous Function"),Object(i.b)("p",null,"In cafe anonymous function can be implemented using syntax below:\nSyntax"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"func ([params]) {   \n    # statements\n}\n")),Object(i.b)("p",null,"Example:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},'var acc = {  \n    init: func(){    \n        this.amount = 0;  \n    },  \n    updateBal: func(amt){    \n        this.amount = this.amount+amt;  \n    },  \n    checkBalance: func(){    \n        cmd.println(this.amount);  \n    },  \n    deposit: func(b){    \n        this.updateBal(b);  \n    },  \n    withdraw: func(b){    \n        if(this.amount < b){      \n            cmd.println("Insufficient Balance");    \n        } else {      \n            updateBal(-b);    \n        }  \n    }\n};\nacc.init();\nacc.checkBalance();\nacc.deposit(1000);\nacc.withdraw(2000);\nacc.checkBalance();\n\n\n')))}s.isMDXComponent=!0}}]);